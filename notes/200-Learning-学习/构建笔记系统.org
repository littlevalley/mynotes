---
#+title: 构建笔记系统
date: 2021年09月28日
tags: [笔记,知识库]
categories: [学习,技能]
---

俗话说好记性不如烂笔头，可见笔记的重要性。每天发生的事，看过的内容，灵光一闪的想
法，随手记在了一个文档里，或者CTRL+S 保存到了一个文件夹中，时间一长再来翻看，觉
得极其混乱，已经记不清楚自己收集了些什么。假设在写笔记的时候放到指定的位置，假设
有一个工具能把自己保存的网页进行简单的整理，必将大大增加学习和积累的效率。

* 构建目录
我还是习惯把笔记按文件目录来进行分类组织，这样显得更加有条理，对于即使没有搜索工
具也比较容易找到自己想找的内容。但具体如何通过目录构建一个合理的有序的系统目录就
很困难了，可以参考网上的一篇贴子，大体就是像图书馆管理图书一样来管理文件夹，给每
个文件夹名字编一个序号，比如一级目录分别是100生活、200学习、300工作，那么二级目
录的构建办法是，在生活目录下建立110旅游、120摄影、130钢琴等等，这里只是一个举例，
可以很容易看出这里有一个缺陷就是每个类别只能安排9个子类，其实不然，有两种解决方
式，一是使用两类数来表示一个层级，二是使用26进制来表示。

究竟如何分类，每个人有自己的想法。我们不可能像维基百科一样来进行分类，因为每个人
的经历和精力都有限，你真正接触的东西并不多。即使有些东西是你一时兴起，顺手存了下
来，如果三个月你没有再去翻看他或者没有到网上再去搜索他，那么你可以将他删了。

将笔记分成工作、生活、学习和兴趣应该是比较合理的，按照GTD的做法，当你想像你每天
从起床到睡觉期间的所有事情，无外乎就这么几类。二级类别就看自己的实际了，每个人都
可能不一样。

我的目录是这样的：
#+begin_example
/home/paul/mynotes/
├── inbox             #保存网页的地方，第个html 文件配有一个XX_files 文件夹
├── notes             #我整理的笔记
│   ├── 100-Work-工作
│   ├── 200-Learning-学习
│   ├── 300-Life-生活
│   │   └── 301-Education-教育
│   └── 400-Meaning-兴趣
│       ├── 410-Programing-编程
│       │   ├── 411-C++-C++
│       │   ├── 412-Python-Python
│       │   ├── 412-VBA-VBA
│       │   └── 413-Shell-Shell
│       ├── 420-Linux-Linux操作系统
│       ├── 430-FreeBSD-BSD操作系统
│       ├── 440-FVWM-FVWM窗口管理器
│       ├── 450-Emacs-神之编辑器
│       └── 460-Hardware-硬件
├── publish
├── static
│   ├── css
│   └── images
└── working_space
#+end_example

* 发布成HTML

我在撰写笔记的时候可以通过Emacs org-mode 进行书写，便是在阅读的时候我还是希望他
的显示更加漂亮，如果通过发布做为自己的静态页面博客与世界进行分享就最好了。网上已
经有方法批量将 org 发布成 html 页面了，实际上就是运用 org-mode-publish ，使用
make 配合 emacs 的 load-file 可以针对自己每个项目的需要灵活地设置发布页面的风格。
虽然网上记录批量发布的方法多，但好多看起来并没有深入地研究过，只不过是把自己做成
功的配置贴出来罢了，而其中不乏错误之处。

** 撰写Makefile
网上的《四步教你从零开始写Makefile》确实不错，但《跟我一起写Makefile》更是值得去
读。
#+begin_src makefile
#将函数的执行结果赋给变量
src = $(wildcard ./*.c)  
obj = $(patsubst %.c, %.o, $(src))  
target = app  
CC = gcc  

$(target): $(obj)  
    $(CC) $(obj) -o $(target)  

%.o: %.c  
    $(CC) -c $< -o $@  

.PHONY: clean  
clean:  
    rm -rf $(obj) $(target) 

#+end_src makefile

然而教程是教程，在实际操作过程中，即使要正确理解 make 的变量处理就非常不容易。以
下是撰写Makefile 中遇到的需要注意的地方：

1. 注释符号的位置如果在变量赋值语句的后面时要特别关注，要么是有特殊用途，要么就
   是一个BUG。
2. make 在处理 Makefile 时对其中 $var 或者 $(fun) 执行的是一遍“替换”。这里替换
   是非常重要的概念，特别是他的函数如果没有达到你的期望最大的可能是你传给他的变
   量的替换结果是个空。
3. 如果规则不写在一行的话，前一条规则中生成的变量并不会作用于后一条规则。
4. 如果规则是一条复杂的Shell 命令的话，如果其中使用 Makefile 函数没有产生预期作
   用时，很有可能是你没有理解“替换”的过程，它是先替换再执行 shell 命令。如果函
   数参数是 shell 命令产生的结果的时候，你使用的Makefile 函数一定得到个寂寞。
5. shell 编程太重要了。

** org 发布设置
由于Emacs 有 --eval 参数，再配合 load-file 允许我们指定加载执行的配置文件，这样
可以针对每一个工程（相对独立的放到一个文件夹中的所有的org 文件的集合）设置不同的
转换风格。比如将设置放到 publish-config.el 文件中，那么运行如下命令即可。
#+begin_src bash 
 emacs --eval "(load-file \"publish-config\")" 
#+end_src bash

*** 网站stylesheet
org-mode 输出成 html 默认的样式确实不好看，在github 上有很多目维护着兼容某个org
版本的css 文件，可以选择自己觉得好看的下载下来，放到 static/css 目录下，而后在
publish-config.el 文件中设置 org-publish-project-alias 变量的值应用样式文件。

*** 网站preamble 和 postamble
org-mode 的有关变量为我们预留了修改生成的网站风格的极大的自由度，就像Emacs 中的
钩子一样，允许我们个性的自由发挥，这就是Linux 哲学的一脉相承。如果作为一个博客网
站，没有一个网站的标题或者是导航，看起来很单调，并且也不方便。这可通过修改
org-preamble-string 为实现。

*** 网站sitemap

org-mode 具有生成网站地图的功能，但是他不支持二级目录，并且风格有限，虽然可以通
过写 elisp 为实现，但为选择自己在 Makefile 中来实现。

* 版本控制

选择github 就好。



本作品采用[[http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh][知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议]] 进行许可。

