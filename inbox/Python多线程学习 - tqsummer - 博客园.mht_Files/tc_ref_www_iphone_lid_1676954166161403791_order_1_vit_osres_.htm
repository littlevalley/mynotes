<html><!--STATUS OK--><head><meta charset="UTF-8">

<meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=0" name="viewport"><meta name="baidu-tc" content="siteapp"><title>Python多线程学习 - tqsummer - 博客园</title><link type="text/css" rel="stylesheet" href="ss-0.6.35.css"></head><body data-dict="20" data-srd="1" class="PAGE_TYPE_NEWS_CONTENT WIDE_STRUCT Blocks_cont_5 Sitetype_6 Struct_page_type_1 hAndroid" data-page_type="PAGE_TYPE_NEWS_CONTENT"><header class="ssPageHeader"><nav class="pageNav"><i onclick="history.back()" class="icon top-back" data-tj="backBtn"></i><span class="slogan">博客园</span><i class="icon search tap" data-showel="#searchFormBox" data-tj="searchFormBox" data-action="saNavTabSelector"></i><a class="tap h-nav-more icon" data-showel="#navMenuList" data-tj="navMenuList" data-action="saNavTabSelector"></a></nav><div id="navMenuList" class="navCard noDis"><div class="hCard saNavCard"><div class="saFastLink"><div class="saFastLinkRow"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;tj=navMenuLinkTap&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2F" class="">首页</a><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;tj=navMenuLinkTap&amp;src=http%3A%2F%2Fq.cnblogs.com%2F" class="">博问</a><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;tj=navMenuLinkTap&amp;src=http%3A%2F%2Fhome.cnblogs.com%2Fing%2F" class="">闪存</a></div><div class="saFastLinkRow"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;tj=navMenuLinkTap&amp;src=http%3A%2F%2Fi.cnblogs.com%2FEditPosts.aspx%3Fopt%3D1" class="">新随笔</a><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;tj=navMenuLinkTap&amp;src=http%3A%2F%2Fspace.cnblogs.com%2Fmsg%2Fsend%2Ftqsummer" class="">联系</a><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;tj=navMenuLinkTap&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Frss" class="">订阅</a></div><div class="saFastLinkRow"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;tj=navMenuLinkTap&amp;src=http%3A%2F%2Fi.cnblogs.com%2F" class="">管理</a></div></div></div></div><div id="searchFormBox" class="navCard noDis"><div class="hCard saNavSearchBox"><form class="saBDSearch" action="http://m.baidu.com/s" method="get"><input placeholder="请输入内容" type="text" name="word" value=""><input type="submit" value="百度一下"><input type="hidden" name="from" value="1001983a"></form></div></div></header><div class="w-normal yi-normal-title" ssweight="1">Python多线程学习 </div><div class=" yi-content-text" ssweight="1"><div><span>一、</span><span>Python</span><span>中的线程使用：</span></div><div><span>Python</span><span>中使用线程有两种方式：函数或者用类来包装线程对象。</span></div><div><span>1、</span><span class=" tc-normal-distance2">函数式：调用</span><span>thread</span><span>模块中的</span><span>start_new_thread()</span><span>函数来产生新线程。如下例：</span></div><div><span>import</span><span>time  </span></div><div><span>import</span><span>thread  </span></div><div><span>def</span><span>timer(no, interval):  </span></div><div><span>cnt = </span><span>0</span></div><div><span>while</span><span>cnt&lt;</span><span>10</span><span>:  </span></div><div><span>print</span><span>'Thread:(%d) Time:%s\n'</span><span>%(no, time.ctime())  </span></div><div><span>time.sleep(interval)  </span></div><div><span>cnt+=</span><span>1</span></div><div><span>thread.exit_thread()  </span></div><div><span>def</span><span>test(): </span><span>#Use thread.start_new_thread() to create 2 new threads</span></div><div><span>thread.start_new_thread(timer, (</span><span>1</span><span>,</span><span>1</span><span>))  </span></div><div><span>thread.start_new_thread(timer, (</span><span>2</span><span>,</span><span>2</span><span>))  </span></div><div><span>if</span><span>__name__==</span><span>'__main__'</span><span>:  </span></div><div><span>test()  </span></div><div><span>上面的例子定义了一个线程函数</span><span>timer,</span><span>它打印出</span><span>10</span><span>条时间记录后退出，每次打印的间隔由</span><span>interval</span><span>参数决定。</span><span>thread.start_new_thread(function, args[, kwargs])</span><span>的第一个参数是线程函数（本例中的</span><span>timer</span><span>方法），第二个参数是传递给线程函数的参数，它必须是</span><span>tuple</span><span>类型，</span><span>kwargs</span><span>是可选参数。</span></div><div><span>线程的结束可以等待线程自然结束，也可以在线程函数中调用</span><span>thread.exit()</span><span>或</span><span>thread.exit_thread()</span><span>方法。</span></div><div><span>2、</span><span class=" tc-normal-distance2">创建</span><span>threading.Thread</span><span>的子类来包装一个线程对象，如下例：</span></div><div><span>import</span><span>threading  </span></div><div><span>import</span><span>time  </span></div><div><span>class</span><span>timer(threading.Thread): </span><span>#The timer class is derived from the class threading.Thread</span></div><div><span>def</span><span>__init__(</span><span>self</span><span>, num, interval):  </span></div><div><span>threading.Thread.__init__(</span><span>self</span><span>)  </span></div><div><span>self</span><span>.thread_num = num  </span></div><div><span>self</span><span>.interval = interval  </span></div><div><span>self</span><span>.thread_stop = </span><span>False</span></div><div><span>def</span><span>run(</span><span>self</span><span>): </span><span>#Overwrite run() method, put what you want the thread do here</span></div><div><span>while</span><span>not</span><span>self</span><span>.thread_stop:  </span></div><div><span>print</span><span>'Thread Object(%d), Time:%s\n'</span><span>%(</span><span>self</span><span>.thread_num, time.ctime())  </span></div><div><span>time.sleep(</span><span>self</span><span>.interval)  </span></div><div><span>def</span><span>stop(</span><span>self</span><span>):  </span></div><div><span>self</span><span>.thread_stop = </span><span>True</span></div><div><span>def</span><span>test():  </span></div><div><span>thread1 = timer(</span><span>1</span><span>, </span><span>1</span><span>)  </span></div><div><span>thread2 = timer(</span><span>2</span><span>, </span><span>2</span><span>)  </span></div><div><span>thread1.start()  </span></div><div><span>thread2.start()  </span></div><div><span>time.sleep(</span><span>10</span><span>)  </span></div><div><span>thread1.stop()  </span></div><div><span>thread2.stop()  </span></div><div><span>return</span></div><div><span>if</span><span>__name__ == </span><span>'__main__'</span><span>:  </span></div><div><span>test()  </span></div><div><span>就我个人而言，比较喜欢第二种方式，即创建自己的线程类，必要时重写</span><span>threading.Thread</span><span>类的方法，线程的控制可以由自己定制。</span></div><div><span>threading.Thread</span><span>类的使用：</span></div><div><span>1</span><span>，在自己的线程类的</span><span>__init__</span><span>里调用</span><span>threading.Thread.__init__(self, name = threadname)</span></div><div><span>Threadname</span><span>为线程的名字</span></div><div><span>2</span><span>，</span><span>run()</span><span>，通常需要重写，编写代码实现做需要的功能。</span></div><div><span>3</span><span>，</span><span>getName()</span><span>，获得线程对象名称</span></div><div><span>4</span><span>，</span><span>setName()</span><span>，设置线程对象名称</span></div><div><span>5</span><span>，</span><span>start()</span><span>，启动线程</span></div><div><span>6</span><span>，</span><span>jion([timeout])</span><span>，等待另一线程结束后再运行。</span></div><div><span>7</span><span>，</span><span>setDaemon(bool)</span><span>，设置子线程是否随主线程一起结束，必须在</span><span>start()</span><span>之前调用。默认为</span><span>False</span><span>。</span></div><div><span>8</span><span>，</span><span>isDaemon()</span><span>，判断线程是否随主线程一起结束。</span></div><div><span>9</span><span>，</span><span>isAlive()</span><span>，检查线程是否在运行中。</span></div><div><span>此外</span><span>threading</span><span>模块本身也提供了很多方法和其他的类，可以帮助我们更好的使用和管理线程。可以参看</span><span><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;src=http%3A%2F%2Fwww.python.org%2Fdoc%2F2.5.2%2Flib%2Fmodule-threading.html">http://www.python.org/doc/2.5.2/lib/module-threading.html</a></span><span>。</span></div><div><span>假设两个线程对象</span><span>t1</span><span>和</span><span>t2</span><span>都要对</span><span>num=0</span><span>进行增</span><span>1</span><span>运算，</span><span>t1</span><span>和</span><span>t2</span><span>都各对</span><span>num</span><span>修改</span><span>10</span><span>次，</span><span>num</span><span>的最终的结果应该为</span><span>20</span><span>。但是由于是多线程访问，有可能出现下面情况：在</span><span>num=0</span><span>时，</span><span>t1</span><span>取得</span><span>num=0</span><span>。系统此时把</span><span>t1</span><span>调度为</span><span>”sleeping”</span><span>状态，把</span><span>t2</span><span>转换为</span><span>”running”</span><span>状态，</span><span>t2</span><span>页获得</span><span>num=0</span><span>。然后</span><span>t2</span><span>对得到的值进行加</span><span>1</span><span>并赋给</span><span>num</span><span>，使得</span><span>num=1</span><span>。然后系统又把</span><span>t2</span><span>调度为</span><span>”sleeping”</span><span>，把</span><span>t1</span><span>转为</span><span>”running”</span><span>。线程</span><span>t1</span><span>又把它之前得到的</span><span>0</span><span>加</span><span>1</span><span>后赋值给</span><span>num</span><span>。这样，明明</span><span>t1</span><span>和</span><span>t2</span><span>都完成了</span><span>1</span><span>次加</span><span>1</span><span>工作，但结果仍然是</span><span>num=1</span><span>。</span></div><div><span>上面的</span><span>case</span><span>描述了多线程情况下最常见的问题之一：数据共享。当多个线程都要去修改某一个共享数据的时候，我们需要对数据访问进行同步。</span></div><div><span>1、</span><span>简单的同步</span></div><div><span>最简单的同步机制就是“锁”。锁对象由</span><span>threading.RLock</span><span>类创建。线程可以使用锁的</span><span>acquire()</span><span>方法获得锁，这样锁就进入“</span><span>locked</span><span>”状态。每次只有一个线程可以获得锁。如果当另一个线程试图获得这个锁的时候，就会被系统变为“</span><span>blocked</span><span>”状态，直到那个拥有锁的线程调用锁的</span><span>release()</span><span>方法来释放锁，这样锁就会进入“</span><span>unlocked</span><span>”状态。“</span><span>blocked</span><span>”状态的线程就会收到一个通知，并有权利获得锁。如果多个线程处于“</span><span>blocked</span><span>”状态，所有线程都会先解除“</span><span>blocked</span><span>”状态，然后系统选择一个线程来获得锁，其他的线程继续沉默（“</span><span>blocked</span><span>”）。</span></div><div><span>Python</span><span>中的</span><span>thread</span><span>模块和</span><span>Lock</span><span>对象是</span><span>Python</span><span>提供的低级线程控制工具，使用起来非常简单。如下例所示：</span></div><div><span>import</span><span>thread  </span></div><div><span>import</span><span>time  </span></div><div><span>mylock = thread.allocate_lock()  </span><span>#Allocate a lock</span></div><div><span>num=</span><span>0</span><span class="comment tc-normal-distance2">#Shared resource</span></div><div><span>def</span><span>add_num(name):  </span></div><div><span>global</span><span>num  </span></div><div><span>while</span><span>True</span><span>:  </span></div><div><span>mylock.acquire() </span><span>#Get the lock </span></div><div><span># Do something to the shared resource</span></div><div><span>print</span><span>'Thread %s locked! num=%s'</span><span>%(name,str(num))  </span></div><div><span>if</span><span>num &gt;= </span><span>5</span><span>:  </span></div><div><span>print</span><span>'Thread %s released! num=%s'</span><span>%(name,str(num))  </span></div><div><span>mylock.release()  </span></div><div><span>thread.exit_thread()  </span></div><div><span>num+=</span><span>1</span></div><div><span>print</span><span>'Thread %s released! num=%s'</span><span>%(name,str(num))  </span></div><div><span>mylock.release()  </span><span>#Release the lock.</span></div><div><span>def</span><span>test():  </span></div><div><span>thread.start_new_thread(add_num, (</span><span>'A'</span><span>,))  </span></div><div><span>thread.start_new_thread(add_num, (</span><span>'B'</span><span>,))  </span></div><div><span>if</span><span>__name__== </span><span>'__main__'</span><span>:  </span></div><div><span>test()  </span></div><div><span>Python </span><span>在</span><span>thread</span><span>的基础上还提供了一个高级的线程控制库，就是之前提到过的</span><span>threading</span><span>。</span><span>Python</span><span>的</span><span>threading module</span><span>是在建立在</span><span>thread module</span><span>基础之上的一个</span><span>module</span><span>，在</span><span>threading module</span><span>中，暴露了许多</span><span>thread module</span><span>中的属性。在</span><span>thread module</span><span>中，</span><span>python</span><span>提供了用户级的线程同步工具“</span><span>Lock</span><span>”对象。而在</span><span>threading module</span><span>中，</span><span>python</span><span>又提供了</span><span>Lock</span><span>对象的变种</span><span>: RLock</span><span>对象。</span><span>RLock</span><span>对象内部维护着一个</span><span>Lock</span><span>对象，它是一种可重入的对象。对于</span><span>Lock</span><span>对象而言，如果一个线程连续两次进行</span><span>acquire</span><span>操作，那么由于第一次</span><span>acquire</span><span>之后没有</span><span>release</span><span>，第二次</span><span>acquire</span><span>将挂起线程。这会导致</span><span>Lock</span><span>对象永远不会</span><span>release</span><span>，使得线程死锁。</span><span>RLock</span><span>对象允许一个线程多次对其进行</span><span>acquire</span><span>操作，因为在其内部通过一个</span><span>counter</span><span>变量维护着线程</span><span>acquire</span><span>的次数。而且每一次的</span><span>acquire</span><span>操作必须有一个</span><span>release</span><span>操作与之对应，在所有的</span><span>release</span><span>操作完成之后，别的线程才能申请该</span><span>RLock</span><span>对象。</span></div><div><span>下面来看看如何使用</span><span>threading</span><span>的</span><span>RLock</span><span>对象实现同步。</span></div><div><span>import</span><span>threading  </span></div><div><span>mylock = threading.RLock()  </span></div><div><span>num=</span><span>0</span></div><div><span>class</span><span>myThread(threading.Thread):  </span></div><div><span>def</span><span>__init__(</span><span>self</span><span>, name):  </span></div><div><span>threading.Thread.__init__(</span><span>self</span><span>)  </span></div><div><span>self</span><span>.t_name = name  </span></div><div><span>def</span><span>run(</span><span>self</span><span>):  </span></div><div><span>global</span><span>num  </span></div><div><span>while</span><span>True</span><span>:  </span></div><div><span>mylock.acquire()  </span></div><div><span>print</span><span>'\nThread(%s) locked, Number: %d'</span><span>%(</span><span>self</span><span>.t_name, num)  </span></div><div><span>if</span><span>num&gt;=</span><span>4</span><span>:  </span></div><div><span>mylock.release()  </span></div><div><span>print</span><span>'\nThread(%s) released, Number: %d'</span><span>%(</span><span>self</span><span>.t_name, num)  </span></div><div><span>break</span></div><div><span>num+=</span><span>1</span></div><div><span>print</span><span>'\nThread(%s) released, Number: %d'</span><span>%(</span><span>self</span><span>.t_name, num)  </span></div><div><span>mylock.release()  </span></div><div><span>def</span><span>test():  </span></div><div><span>thread1 = myThread(</span><span>'A'</span><span>)  </span></div><div><span>thread2 = myThread(</span><span>'B'</span><span>)  </span></div><div><span>thread1.start()  </span></div><div><span>thread2.start()  </span></div><div><span>if</span><span>__name__== </span><span>'__main__'</span><span>:  </span></div><div><span>test()  </span></div><div><span>我们把修改共享数据的代码成为“临界区”。必须将所有“临界区”都封闭在同一个锁对象的</span><span>acquire</span><span>和</span><span>release</span><span>之间。</span></div><div><span>2、</span><span>条件同步</span></div><div><span>锁只能提供最基本的同步。假如只在发生某些事件时才访问一个“临界区”，这时需要使用条件变量</span><span>Condition</span><span>。</span></div><div><span>Condition</span><span>对象是对</span><span>Lock</span><span>对象的包装，在创建</span><span>Condition</span><span>对象时，其构造函数需要一个</span><span>Lock</span><span>对象作为参数，如果没有这个</span><span>Lock</span><span>对象参数，</span><span>Condition</span><span>将在内部自行创建一个</span><span>Rlock</span><span>对象。在</span><span>Condition</span><span>对象上，当然也可以调用</span><span>acquire</span><span>和</span><span>release</span><span>操作，因为内部的</span><span>Lock</span><span>对象本身就支持这些操作。但是</span><span>Condition</span><span>的价值在于其提供的</span><span>wait</span><span>和</span><span>notify</span><span>的语义。</span></div><div><span>条件变量是如何工作的呢？首先一个线程成功获得一个条件变量后，调用此条件变量的</span><span>wait()</span><span>方法会导致这个线程释放这个锁，并进入“</span><span>blocked</span><span>”状态，直到另一个线程调用同一个条件变量的</span><span>notify()</span><span>方法来唤醒那个进入“</span><span>blocked</span><span>”状态的线程。如果调用这个条件变量的</span><span>notifyAll()</span><span>方法的话就会唤醒所有的在等待的线程。</span></div><div><span>如果程序或者线程永远处于“</span><span>blocked</span><span>”状态的话，就会发生死锁。所以如果使用了锁、条件变量等同步机制的话，一定要注意仔细检查，防止死锁情况的发生。对于可能产生异常的临界区要使用异常处理机制中的</span><span>finally</span><span>子句来保证释放锁。等待一个条件变量的线程必须用</span><span>notify()</span><span>方法显式的唤醒，否则就永远沉默。保证每一个</span><span>wait()</span><span>方法调用都有一个相对应的</span><span>notify()</span><span>调用，当然也可以调用</span><span>notifyAll()</span><span>方法以防万一。</span></div><div><span>生产者与消费者问题是典型的同步问题。这里简单介绍两种不同的实现方法。</span></div><div><span>1，</span><span class=" tc-normal-distance2">条件变量</span></div><div><span>import</span><span>threading  </span></div><div><span>import</span><span>time  </span></div><div><span>class</span><span>Producer(threading.Thread):  </span></div><div><span>def</span><span>__init__(</span><span>self</span><span>, t_name):  </span></div><div><span>threading.Thread.__init__(</span><span>self</span><span>, name=t_name)  </span></div><div><span>def</span><span>run(</span><span>self</span><span>):  </span></div><div><span>global</span><span>x  </span></div><div><span>con.acquire()  </span></div><div><span>if</span><span>x &gt; </span><span>0</span><span>:  </span></div><div><span>con.wait()  </span></div><div><span>else</span><span>:  </span></div><div><span>for</span><span>i </span><span>in</span><span>range(</span><span>5</span><span>):  </span></div><div><span>x=x+</span><span>1</span></div><div><span>print</span><span>"producing..."</span><span>+ str(x)  </span></div><div><span>con.notify()  </span></div><div><span>print</span><span>x  </span></div><div><span>con.release()  </span></div><div><span>class</span><span>Consumer(threading.Thread):  </span></div><div><span>def</span><span>__init__(</span><span>self</span><span>, t_name):  </span></div><div><span>threading.Thread.__init__(</span><span>self</span><span>, name=t_name)  </span></div><div><span>def</span><span>run(</span><span>self</span><span>):  </span></div><div><span>global</span><span>x  </span></div><div><span>con.acquire()  </span></div><div><span>if</span><span>x == </span><span>0</span><span>:  </span></div><div><span>print</span><span>'consumer wait1'</span></div><div><span>con.wait()  </span></div><div><span>else</span><span>:  </span></div><div><span>for</span><span>i </span><span>in</span><span>range(</span><span>5</span><span>):  </span></div><div><span>x=x-</span><span>1</span></div><div><span>print</span><span>"consuming..."</span><span>+ str(x)  </span></div><div><span>con.notify()  </span></div><div><span>print</span><span>x  </span></div><div><span>con.release()  </span></div><div><span>con = threading.Condition()  </span></div><div><span>x=</span><span>0</span></div><div><span>print</span><span>'start consumer'</span></div><div><span>c=Consumer(</span><span>'consumer'</span><span>)  </span></div><div><span>print</span><span>'start producer'</span></div><div><span>p=Producer(</span><span>'producer'</span><span>)  </span></div><div><span>p.start()  </span></div><div><span>c.start()  </span></div><div><span>p.join()  </span></div><div><span>c.join()  </span></div><div><span>print</span><span>x  </span></div><div><span>上面的例子中，在初始状态下，</span><span>Consumer</span><span>处于</span><span>wait</span><span>状态，</span><span>Producer</span><span>连续生产（对</span><span>x</span><span>执行增</span><span>1</span><span>操作）</span><span>5</span><span>次后，</span><span>notify</span><span>正在等待的</span><span>Consumer</span><span>。</span><span>Consumer</span><span>被唤醒开始消费（对</span><span>x</span><span>执行减</span><span>1</span><span>操作）</span></div><div><span>2，</span><span class=" tc-normal-distance2">同步队列</span></div><div><span>Python</span><span>中的</span><span>Queue</span><span>对象也提供了对线程同步的支持。使用</span><span>Queue</span><span>对象可以实现多个生产者和多个消费者形成的</span><span>FIFO</span><span>的队列。</span></div><div><span>生产者将数据依次存入队列，消费者依次从队列中取出数据。</span></div><div><span># producer_consumer_queue</span></div><div><span>from</span><span>Queue </span><span>import</span><span>Queue  </span></div><div><span>import</span><span>random  </span></div><div><span>import</span><span>threading  </span></div><div><span>import</span><span>time  </span></div><div><span>#Producer thread</span></div><div><span>class</span><span>Producer(threading.Thread):  </span></div><div><span>def</span><span>__init__(</span><span>self</span><span>, t_name, queue):  </span></div><div><span>threading.Thread.__init__(</span><span>self</span><span>, name=t_name)  </span></div><div><span>self</span><span>.data=queue  </span></div><div><span>def</span><span>run(</span><span>self</span><span>):  </span></div><div><span>for</span><span>i </span><span>in</span><span>range(</span><span>5</span><span>):  </span></div><div><span>print</span><span>"%s: %s is producing %d to the queue!\n"</span><span>%(time.ctime(), </span><span>self</span><span>.getName(), i)  </span></div><div><span>self</span><span>.data.put(i)  </span></div><div><span>time.sleep(random.randrange(</span><span>10</span><span>)/</span><span>5</span><span>)  </span></div><div><span>print</span><span>"%s: %s finished!"</span><span>%(time.ctime(), </span><span>self</span><span>.getName())  </span></div><div><span>#Consumer thread</span></div><div><span>class</span><span>Consumer(threading.Thread):  </span></div><div><span>def</span><span>__init__(</span><span>self</span><span>, t_name, queue):  </span></div><div><span>threading.Thread.__init__(</span><span>self</span><span>, name=t_name)  </span></div><div><span>self</span><span>.data=queue  </span></div><div><span>def</span><span>run(</span><span>self</span><span>):  </span></div><div><span>for</span><span>i </span><span>in</span><span>range(</span><span>5</span><span>):  </span></div><div><span>val = </span><span>self</span><span>.data.get()  </span></div><div><span>print</span><span>"%s: %s is consuming. %d in the queue is consumed!\n"</span><span>%(time.ctime(), </span><span>self</span><span>.getName(), val)  </span></div><div><span>time.sleep(random.randrange(</span><span>10</span><span>))  </span></div><div><span>print</span><span>"%s: %s finished!"</span><span>%(time.ctime(), </span><span>self</span><span>.getName())  </span></div><div><span>#Main thread</span></div><div><span>def</span><span>main():  </span></div><div><span>queue = Queue()  </span></div><div><span>producer = Producer(</span><span>'Pro.'</span><span>, queue)  </span></div><div><span>consumer = Consumer(</span><span>'Con.'</span><span>, queue)  </span></div><div><span>producer.start()  </span></div><div><span>consumer.start()  </span></div><div><span>producer.join()  </span></div><div><span>consumer.join()  </span></div><div><span>print</span><span>'All threads terminate!'</span></div><div><span>if</span><span>__name__ == </span><span>'__main__'</span><span>:  </span></div><div><span>main()  </span></div><div><span>在上面的例子中，</span><span>Producer</span><span>在随机的时间内生产一个“产品”，放入队列中。</span><span>Consumer</span><span>发现队列中有了“产品”，就去消费它。本例中，由于</span><span>Producer</span><span>生产的速度快于</span><span>Consumer</span><span>消费的速度，所以往往</span><span>Producer</span><span>生产好几个“产品”后，</span><span>Consumer</span><span>才消费一个产品。</span></div><div><span>Queue</span><span>模块实现了一个支持多</span><span>producer</span><span>和多</span><span>consumer</span><span>的</span><span>FIFO</span><span>队列。当共享信息需要安全的在多线程之间交换时，</span><span>Queue</span><span>非常有用。</span><span>Queue</span><span>的默认长度是无限的，但是可以设置其构造函数的</span><span>maxsize</span><span>参数来设定其长度。</span><span>Queue</span><span>的</span><span>put</span><span>方法在队尾插入，该方法的原型是：</span></div><div><span>put(</span><span>item[, block[, timeout]])</span></div><div><span>如果可选参数</span><span>block</span><span>为</span><span>true</span><span>并且</span><span>timeout</span><span>为</span><span>None</span><span>（缺省值），线程被</span><span>block</span><span>，直到队列空出一个数据单元。如果</span><span>timeout</span><span>大于</span><span>0</span><span>，在</span><span>timeout</span><span>的时间内，仍然没有可用的数据单元，</span><span>Full exception</span><span>被抛出。反之，如果</span><span>block</span><span>参数为</span><span>false</span><span>（忽略</span><span>timeout</span><span>参数），</span><span>item</span><span>被立即加入到空闲数据单元中，如果没有空闲数据单元，</span><span>Full exception</span><span>被抛出。</span></div><div><span>Queue</span><span>的</span><span>get</span><span>方法是从队首取数据，其参数和</span><span>put</span><span>方法一样。如果</span><span>block</span><span>参数为</span><span>true</span><span>且</span><span>timeout</span><span>为</span><span>None</span><span>（缺省值），线程被</span><span>block</span><span>，直到队列中有数据。如果</span><span>timeout</span><span>大于</span><span>0</span><span>，在</span><span>timeout</span><span>时间内，仍然没有可取数据，</span><span>Empty exception</span><span>被抛出。反之，如果</span><span>block</span><span>参数为</span><span>false</span><span>（忽略</span><span>timeout</span><span>参数），队列中的数据被立即取出。如果此时没有可取数据，</span><span>Empty exception</span><span>也会被抛出。</span></div></div><div class="yi-prenext" ssweight="1"><div class="yi-prenext-title">延伸阅读：</div><a data-addparam="nextpage=1" href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;nextpage=1&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2011%2F01%2F25%2F1944763.html" class="yi-pre"><span class="yi-prenext-a">上一篇</span><span class="yi-fontcolor">python 多线程应用</span></a><a data-addparam="nextpage=1" href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;nextpage=1&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2011%2F02%2F16%2F1955956.html" class="yi-next"><span class="yi-prenext-a">下一篇</span><span class="yi-fontcolor">Java或者JAR包获取读取资源文件的路径的问题总结</span></a></div><div class="newsRecommend" ssweight="1"><div class="newsRecommendTitle">更多内容</div><ul class="newsRecommendUl"><li class="newsRecommendLi"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2011%2F01%2F25%2F1944771.html">1. Python多线程学习(9)</a></li><li class="newsRecommendLi"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2010%2F08%2F26%2F1809232.html">2. Log4j配置实例（log4j.xml）(5)</a></li><li class="newsRecommendLi"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2010%2F08%2F26%2F1809268.html">3. log4j配置说明(1)</a></li><li class="newsRecommendLi"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2011%2F01%2F25%2F1944416.html">4. Python中函数的参数定义和可变参数(1)</a></li><li class="newsRecommendLi"><a href="http://m.baidu.com/from=2001a/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_1003%2Cta%40iphone_2_4.4_1_10.6/baiduid=9A9325E51157B9C6B9B4ACC4923960DA/w=0_10_Python+%E5%A4%9A%E7%BA%BF%E7%A8%8B/t=iphone/l=3/tc?m=8&amp;srd=1&amp;dict=20&amp;title=Python%25u591A%25u7EBF%25u7A0B%25u5B66%25u4E60-tqsummer-%25u535A%25u5BA2%25u56ED&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2011%2F01%2F24%2F1943273.html">5. python __init__.py(1)</a></li></ul></div><div id="web-recommend-new" style="" class="web-recommend-new pannel" data-page-src="http://www.cnblogs.com/tqsummer/archive/2011/01/25/1944771.html"><div class="newsRecommendTitle">大家也在搜</div><ul><li style="padding-top:0" class="item-show"><a class="word hot" data-action="down" href="http://m.baidu.com/s?word=python%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;from=1001560s&amp;pu=ofrom%401001560l&amp;sa=npr_2_1"><span class="word-content">python多线程</span></a></li><li style="padding-top:0" class="item-show"><a class="word" data-action="down" href="http://m.baidu.com/s?word=python&amp;from=1001560t&amp;pu=ofrom%401001560l&amp;sa=npr_2_2"><span class="word-content">python</span></a></li><li class="item-show"><a class="word" data-action="down" href="http://m.baidu.com/s?word=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;from=1001560u&amp;pu=ofrom%401001560l&amp;sa=npr_2_3"><span class="word-content">多线程</span></a></li><li class="item-show"><a class="word" data-action="down" href="http://m.baidu.com/s?word=%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C&amp;from=1001560v&amp;pu=ofrom%401001560l&amp;sa=npr_2_4"><span class="word-content">完美世界</span></a></li><li class="item-show"><a class="word" data-action="down" href="http://m.baidu.com/s?word=%E8%87%AA%E9%94%81%E6%89%98%E6%A7%BD%E7%9F%AB%E6%AD%A3%E5%A4%9A%E5%B0%91%E9%92%B1&amp;from=1001560w&amp;pu=ofrom%401001560l&amp;sa=npr_2_5"><span class="word-content">自锁托槽矫正多少钱</span></a></li><li class="item-show"><a class="word" data-action="down" href="http://m.baidu.com/s?word=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%B9%E8%AE%AD&amp;from=1001560x&amp;pu=ofrom%401001560l&amp;sa=npr_2_6"><span class="word-content">嵌入式培训</span></a></li><li class="item-show"><a class="word hot" data-action="down" href="http://m.baidu.com/s?word=%E4%BB%80%E4%B9%88%E6%98%AF%E7%AA%9D%E6%B2%9F%E5%B0%81%E9%97%AD&amp;from=1001560y&amp;pu=ofrom%401001560l&amp;sa=npr_2_7"><span class="word-content">什么是窝沟封闭</span></a></li><li class="item-show"><a class="word" data-action="down" href="http://m.baidu.com/s?word=%E5%84%BF%E7%AB%A5%E7%89%99%E9%BD%BF%E7%9F%AB%E6%AD%A3&amp;from=1001560z&amp;pu=ofrom%401001560l&amp;sa=npr_2_8"><span class="word-content">儿童牙齿矫正</span></a></li></ul><div style="clear:both;"></div><form class="" action="http://m.baidu.com/s" method="get"><input placeholder="请输入内容" type="text" name="word" value=""><button type="submit" data-tj="contentSearch">百度一下</button><input type="hidden" name="sa" value="ops_1"><input type="hidden" id="ssOfrom" name="ofrom" value=""></form></div><div class="appBanner"><img src="appBanner.png"></div><div class="saFooter"><div class="saFooterOld"><a class="toolbar-pcPageUrl-light yi-www" href="http://m.siteapp.baidu.com/redirect/?from=tcwise&amp;type=pcURLBottom&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2011%2F01%2F25%2F1944771.html&amp;mask=855665c5f42edc0eab9f5be4a6034744"><span>电脑版</span></a><a class="toolbar-goBack-light yi-www" href="tc_ref_www_iphone_lid_1676954166161403791_order_1_vit_osres_.htm#"><span>回顶部</span></a></div><div class="saFooterNew"><a target="_blank" class="yi-www" href="http://m.baidu.com/pub/help.php?pn=22&amp;ssid=0&amp;from=844b&amp;bd_page_type=1&amp;uid=&amp;pu=usm%405%2Csz%401330_220%2Cta%40big_3_7.5_4_9.0">转码声明</a><a target="_blank" class="yi-www" href="http://feedback.baidu.com/">用户反馈</a><a target="_blank" class="yi-www" href="http://m.siteapp.baidu.com/redirect/?from=tcwise&amp;type=pcWebSiteCallBack&amp;src=http%3A%2F%2Fm.siteapp.baidu.com%2Frenling%2Frenling.php%3Ffrom%3Dbaidusearch%26domain%3Dcnblogs.com&amp;mask=5db8e56a2d6f457a0d0758c0d9cd3a6d">站长认领</a></div></div><div id="tool-box"><div id="tool-bg"><div id="tool-bar"><a class="toolbar-search yi-www" data-action="down" href="http://m.baidu.com/?from=1001983a"><i class="icon"></i>百度</a><a class="toolbar-goBack yi-www tap" data-action="down" data-js="saHideToolBarBox();"><i class="icon"></i>回顶部</a><a id="toolbar-share" data-action="down" class="toolbar-share"><i class="icon"></i>分享</a><a class="toolbar-pcPageUrl yi-www" data-action="down" href="http://siteapp.baidu.com/app/redirect/?from=tcwise&amp;type=pcURLToolBox&amp;src=http%3A%2F%2Fwww.cnblogs.com%2Ftqsummer%2Farchive%2F2011%2F01%2F25%2F1944771.html"><i class="icon"></i>电脑版</a></div></div><div id="tool-bt"><span data-action="down"></span></div></div><iframe src="mp-cdn.html" style="display: none; "></iframe></body></html>
