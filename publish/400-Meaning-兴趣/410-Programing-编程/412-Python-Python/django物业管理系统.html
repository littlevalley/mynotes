<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2021-10-02 Sat 12:06 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu Peng" />
<link rel='stylesheet' type='text/css' href='file:///home/paul/mynotes/publish/css/org.css' /><link rel='stylesheet' type='text/css' href='file:///home/paul/mynotes/publish/css/header.css' />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<div class="site_header"><div class="site_title" ><div class="title_main">WuPeng's Notes - 我的知识库</div><div class="title_sub">不积跬步，无以至千里；不积小流，无以成江海</div><div class="search"></div></div><div class="nav_bar"><ul><li><a href="file:///home/paul/mynotes/publish/index.html">笔记</a></li><li><a href="file:///home/paul/mynotes/publish/inbox.html">收集</a></li><li><a href="#contact">Contact</a></li><li style="float:right"><a href="file:///home/paul/mynotes/publish/about.html">关于</a></li></ul></div></div>
</div>
<div id="content">
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org91f1f36">1. 开发</a></li>
<li><a href="#org7f3963a">2. 用户认证系统</a></li>
<li><a href="#orgb99acb1">3. 发布</a></li>
<li><a href="#org9c38ad0">4. 安装Apache,libapache2-mod-wsgi</a></li>
<li><a href="#orgbfe68ab">5. 配置</a>
<ul>
<li><a href="#org4f771fd">5.1. 一是站点配置，</a></li>
<li><a href="#orgd1c045c">5.2. 二是wsgi配置</a></li>
<li><a href="#org96a3ad4">5.3. Mysql 配置</a></li>
</ul>
</li>
<li><a href="#org8a637f2">6. 上传</a></li>
<li><a href="#org1fbf7a8">7. 物业管理内容</a></li>
</ul>
</div>
</div>
<div id="outline-container-org91f1f36" class="outline-2">
<h2 id="org91f1f36"><span class="section-number-2">1</span> 开发</h2>
<div class="outline-text-2" id="text-1">
<p>
 用virtualenv 建立开发环境
apt-get install python-pip
pip install virtualenv 
virtualenv  venv
venv是新创建的虚拟环境的名称。 同时会创建一个与虚拟环境名称相同的文件夹venv, 里面存储了一个独立的Python执行环境。
进入虚拟环境
    source venv/bin/activate
    进入虚拟环境后，命令行的提示符会加入虚拟环境的名称，例如：(venv)user@machine:~$
退出虚拟环境$
    deactivate
删除虚拟环境
    rm -r venv
    直接删除虚拟环境所在的文件夹venv就删除了我们创建的venv虚拟环境。
</p>
</div>
</div>

<div id="outline-container-org7f3963a" class="outline-2">
<h2 id="org7f3963a"><span class="section-number-2">2</span> 用户认证系统</h2>
<div class="outline-text-2" id="text-2">
<p>
django认证系统包含三个部分：用户、权限和分组
安装
</p>

<p>
django项目默认启用了认证系统，如果不是使用django-admin.py创建项目的可以通过在settings配置文件里面的INSTALLED_APPS的列表里面添加django.contrib.auth和django.contrib.contenttypes这两项然后运行manage.py syncdb命令创建对应的数据库表即可
用户Users
</p>

<p>
在Django-1.4.10\django\contrib\auth这个目录下有一个model文件，里面有Permission,GroupManager,Group,UserManager,User,AnonymousUser这些类的源码，建议自己都去看一下，很多注释，属性名和方法名都通俗易懂，这里只点一下关键点
</p>

<p>
groups和user_permissions是是多对多的属性，分别对应到了类Group和Permission
</p>

<p>
is_active这个属性提醒我们不要轻易的删掉一些对象，我们可以设置一个标志位标识该对象是否可用
</p>

<p>
set_unusable_password，标识该用户没有密码设置，注意不等同与空密码
基本的用法
创建用户
</p>

<p>
&gt;&gt;&gt; from django.contrib.auth.models import User
&gt;&gt;&gt; user = User.objects.create_user('john', 'lennon@thebeatles.com', 'johnpassword')
&gt;&gt;&gt; user.save()
</p>

<p>
修改密码，注意是使用set_password而不是password属性
</p>

<p>
&gt;&gt;&gt; from django.contrib.auth.models import User
&gt;&gt;&gt; u = User.objects.get(username__exact='john')
&gt;&gt;&gt; u.set_password('new password')
&gt;&gt;&gt; u.save()
</p>

<p>
创建超级用户
</p>

<p>
manage.py createsuperuser &#x2013;username=joe &#x2013;email=joe@example.com
</p>

<p>
存储用户的额外信息
</p>

<p>
这是一个比较麻烦的事情，不过django还是提供了一个定制的方法
</p>

<p>
首先你要定义一个模型，在这个模型里面你可以定制额外的属性或者方法，然后记得添加一个名为user的一对一的属性名
</p>

<p>
from django.contrib.auth.models import User
class UserProfile(models.Model):
</p>

<p>
user = models.OneToOneField(User)
</p>

<p>
accepted_eula = models.BooleanField()
favorite_animal = models.CharField(max_length=20, default="Dragons.")
</p>

<p>
为了表明这个模型是对于那个给定的站点，我们还需要配置一个AUTH_PROFILE_MODULE，这是一个字符串，包含两部分信息，由点号相连
</p>

<p>
app名：大小写敏感，一般是你使用manage.py startapp创建时用的名称
你自定义的模型名称，大小写不敏感
</p>

<p>
比如，app名为accounts，模型名为UserProfile
</p>

<p>
AUTH_PROFILE_MODULE = 'accounts.UserProfile'
</p>

<p>
一旦一个用户档案模型（额外信息模型）被定义然后用上述方法指明，每一个user对象都会有一个方法&#x2013;get_profile()&#x2013;去返回跟该用户相关的额外信息
</p>

<p>
然而，你必须注册一个到django.db.models.signals.post_save信号的处理程序，并且在处理程序里面，如果created为真，才创建关联的用户额外信息
</p>

<p>
from django.contrib.auth.models import User
from django.db.models.signals import post_save
</p>

<p>
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)
</p>

<p>
post_save.connect(create_user_profile, sender=User)
</p>

<p>
把UserProfile添加到admin
</p>

<p>
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from django.contrib.auth.models import User
from my_user_profile_app.models import UserProfile
</p>

<p>
class UserProfileInline(admin.StackedInline):
  model = UserProfile
  can_delete = False
  verbose_name_plural = 'profile'
</p>

<p>
class UserAdmin(UserAdmin):
  inlines = (UserProfileInline, )
</p>

<p>
admin.site.unregister(User)
admin.site.register(User, UserAdmin)
</p>

<p>
匿名用户
</p>

<p>
我们来看一下匿名用户的属性，是对用户的一个补充
</p>

<p>
class AnonymousUser(object):
  id = None
  username = ''
  is_staff = False
  is_active = False
  is_superuser = False
  _groups = EmptyManager()
  _user_permissions = EmptyManager()
</p>

<p>
web请求中的认证
</p>

<p>
前面我们只是谈到了操纵认证相关对象的底层的APIs，在更高的层次，django可以把认证框架钩进请求对象request系统中
</p>

<p>
首先，安装会话中间件和认证中间件（在MIDDLEWARE_CLASSES)里面添加SessionMiddleware和AuthenticationMiddleware，安装好这两个中间件后，你可以在视图函数里面是用request.user（代表当前已经登陆的user对象，如果用户还没等，将代表一个匿名对象），可以使用is_authencated()方法来辨别是否已经登陆
如何登陆用户
</p>

<p>
django提供了两个函数django.contrib.auth:authenticate()和login()
authentecate()
</p>

<p>
用给定的用户名和密码去认证，返回一个User对象或者None
</p>

<p>
from django.contrib.auth import authenticate
user = authenticate(username='john', password='secret')
if user is not None:
    if user.is_active:
        print "You provided a correct username and password!"
    else:
        print "Your account has been disabled!"
else:
    print "Your username and password were incorrect."
</p>

<p>
login()
</p>

<p>
在视图函数中可以使用login()方法去登陆一个用户，这个方法需要一个HttpRequest对象和一个User对象，login()函数把用户ID存在session里面（是用django的session框架，所以请确保启用了会话中间件），如果是手工登陆用户，请先条用authenticate()方法
</p>

<p>
from django.contrib.auth import authenticate, login
def my_view(request):
  username = request.POST['username']
  password = request.POST['password']
  user = authenticate(username=username, password=password)
  if user is not None:
    if user.is_active:
      login(request, user)
</p>

<p>
else:
</p>

<p>
else:
</p>

<p>
如何注销用户
logout()
</p>

<p>
去注销一个使用django.contrib.auth.login()方法登陆的用户，请使用在视图函数中使用django.contrib.auth.logout()方法注销，该方法需要一个HttpRequest对象并且没有返回值
</p>

<p>
from django.contrib.auth import logout
</p>

<p>
def logout_view(request):
    logout(request)
</p>

<p>
限制登陆用户的访问
原始方法
</p>

<p>
在视图函数中检查request.user.is_authencated()是否为真，从而决定是重定向到一个登陆页面或者是错误页面
login_required装饰器
</p>

<p>
decorators. login_required ( [ redirect_field_name=REDIRECT_FIELD_NAME ,  login_url=None ])
</p>

<p>
作为一个快捷方式，可以直接使用login_required()装饰器
</p>

<p>
from django.contrib.auth.decorators import login_required
</p>

<p>
@login_required
def my_view(request):
</p>

<p>
这个装饰器按照以下步骤：
</p>

<p>
如果用户没有登陆，重定向到settings.LOGIN_URL（把在查询字符串中的当前绝对路径传参过去，例如 <i>accounts/login</i>?next=/polls/3/
如果用户已经登陆，正常执行视图函数
</p>

<p>
默认情况下，用户在成功认证后的重定向路径被存在查询字符串中的next参数中，如果你想修改的话，请使用redirect_field_name参数 @login_required ( redirect_field_name = 'my_redirect_field' )
</p>

<p>
注意的是，如果你提供了redirect_field_name，那么你很有可能需要去自定义登陆模板，你可以是用login_url参数 @login_required ( login_url = '<i>accounts/login</i>' )
内建视图函数
</p>

<p>
除了上面提到的login和logout，还有以下内建的视图函数
</p>

<p>
logout_then_login ( request [,  login_url ]) ：注销一个用户然后重定向到一个登陆页面
</p>

<p>
password_change ( request [,  template_name ,  post_change_redirect ,  password_change_form ]) ：允许用户修改他们的密码
</p>

<p>
password_change_done ( request [,  template_name ])：用户修改密码后的页面
</p>

<p>
password_reset ( request [,  is_admin_site ,  template_name ,  email_template_name , password_reset_form ,  token_generator ,  post_reset_redirect ,  from_email ])：通过生成的一个一次性的用来重置密码的发往他们注册邮箱的链接来允许用户重置他们的密码
</p>

<p>
password_reset_done ( request [,  template_name ])：重置密码后的页面
</p>

<p>
password_reset_confirm ( request [,  uidb36 ,  token ,  template_name ,  token_generator , set_password_form ,  post_reset_redirect ])：展示一个用来输入密码的表单
</p>

<p>
redirect_to_login ( next [,  login_url ,  redirect_field_name ])：重定向到一个登陆页面然后在成功登陆后转向另一个url
内建表单
</p>

<p>
如果你不想使用上面的内建视图函数，但是又不想自己写那些表单，你可以是用这些内建的表单，这些内建的表单都位于django.contrib.zuth.forms里面
</p>

<p>
class  AdminPasswordChangeForm
</p>

<p>
A form used in the admin interface to change a user’s password.
</p>

<p>
class  AuthenticationForm
</p>

<p>
A form for logging a user in.
</p>

<p>
class  PasswordChangeForm ¶
</p>

<p>
A form for allowing a user to change their password.
</p>

<p>
class  PasswordResetForm
</p>

<p>
A form for generating and emailing a one-time use link to reset a user’s password.
</p>

<p>
class  SetPasswordForm
</p>

<p>
A form that lets a user change his/her password without entering the old password.
</p>

<p>
class  UserChangeForm
</p>

<p>
A form used in the admin interface to change a user’s information and permissions.
</p>

<p>
class  UserCreationForm
</p>

<p>
A form for creating a new user.
限制通过测试登陆的用户的访问
</p>

<p>
有时候需要检查用户是否有某些权限，或者需要通过其他的测试等等才能访问，比如下面的代码：需要检测用户是否有投票的权限
</p>

<p>
def my_view(request):
    if not request.user.has_perm('polls.can_vote'):
        return HttpResponse("You can't vote in this poll.")
</p>

<p>
user_passes_test ( func [,  login_url=None ])，你可以简单的使用 user_passes_test
</p>

<p>
from django.contrib.auth.decorators import user_passes_test
</p>

<p>
@user_passes_test(lambda u: u.has_perm('polls.can_vote'))
def my_view(request):
</p>

<p>
如果你仅仅是想要检测用户是否有某项权限，你可以是用更简单的permission_required装饰器，user_passes_test不会检测用户是否是匿名用户，只是检查是否能通过测试，这点是值得注意的，另外，如果用户没有通过测试，你可以定义login_url来重定向到一个登陆页面，如：
</p>

<p>
@user_passes_test(lambda u: u.has_perm('polls.can_vote'), login_url='<i>login</i>')
</p>

<p>
permission_required装饰器
</p>

<p>
permission_required ( [ login_url=None ,  raise_exception=False ])：检查用户是否具有特定的权限，可以自定义用户不具有要求权限是重定向到登陆页面，以及是否抛出异常等等
</p>

<p>
from django.contrib.auth.decorators import permission_required
</p>

<p>
@permission_required('polls.can_vote', login_url='<i>loginpage</i>')
def my_view(request):
</p>

<p>
权限
</p>

<p>
上面说了很多关于权限的内容，下面我们看看django的权限系统吧
</p>

<p>
django自带一个简单的权限系统 ，提供了给特定用户和组用户赋予权限的方法  ，在django的admin站点被使用，同时你也可以在自己的代码中使用
默认权限
</p>

<p>
当django.contrib.auth被加入INSTALLED_APPS的时候，三项特别的权限&#x2013;添加，修改和删除&#x2013;已经为每个django模型创建好了，这三项权限是在你运行manage.py syncdb的时候创建的
</p>

<p>
假设你有个应用的app_label是foo，一个模型名为Bar，那么你可以这样来测试这三个权限
</p>

<p>
add:  user.has_perm('foo.add_bar')
change:  user.has_perm('foo.change_bar')
delete:  user.has_perm('foo.delete_bar')
</p>

<p>
自定义权限
</p>

<p>
如果要自定义权限的话，请使用permissions这个meta属性，例如：
</p>

<p>
class Task(models.Model):
  &#x2026;
  class Meta:
    permissions = (
      ("view_task", "Can see available tasks"),
      ("change_task_status", "Can change the status of tasks"),
      ("close_task", "Can remove a task by setting its status as closed"),
    )
</p>

<p>
直接在程序中创建权限
</p>

<p>
from myapp.models import BlogPost
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
</p>

<p>
content_type = ContentType.objects.get_for_model(BlogPost)
permission = Permission.objects.create(codename='can_publish',
                                       name='Can Publish Posts',
                                       content_type=content_type)
</p>

<p>
这个方法与上面的方法相比，
权限API
</p>

<p>
直接看一下permission类的源码
</p>

<p>
class Permission(models.Model):
    name = models.CharField(_('name'), max_length=50)
    content_type = models.ForeignKey(ContentType)
    codename = models.CharField(_('codename'), max_length=100)
    objects = PermissionManager()
</p>

<p>
模板中的认证数据
</p>

<p>
当你使用RequestContent的时候，当前已经登陆的用户和其权限在模板上下文中时可用的
Users
</p>

<p>
当前已经登陆的用户（不管是否匿名），数据被存在模板变量{{user}}里面（前提是RequestContext被使用）
</p>

<p>
{% if user.is_authenticated %}
    &lt;p&gt;Welcome, {{ user.username }}. Thanks for logging in.&lt;/p&gt;
{% else %}
    &lt;p&gt;Welcome, new user. Please log in.&lt;/p&gt;
{% endif %}
</p>

<p>
Permissions
</p>

<p>
当前已经登陆的用户的权限被存在模板变量{{perms}}里面
</p>

<p>
{% if perms.foo %}
  &lt;p&gt;You have permission to do something in the foo app.&lt;/p&gt;
  {% if perms.foo.can_vote %}
    &lt;p&gt;You can vote!&lt;/p&gt;
  {% endif %}
  {% if perms.foo.can_drive %}
    &lt;p&gt;You can drive!&lt;/p&gt;
  {% endif %}
{% else %}
  &lt;p&gt;You don't have permission to do anything in the foo app.&lt;/p&gt;
{% endif %}
</p>

<p>
分组
</p>

<p>
看过了用户和权限，我们继续看分组吧
</p>

<p>
分组是最简单的归类的方法，分组之后你可以对组内的用户分配特定的权限或者其他label；当然，一个用户可以属于多个组；一个组里面的用户自动获取改分组拥有的权限
apis
</p>

<p>
我们直接看代码吧，哈哈，就只有组名和对应的权限两项
</p>

<p>
class Group(models.Model):
    name = models.CharField(_('name'), max_length=80, unique=True)
    permissions = models.ManyToManyField(Permission,
        verbose_name=_('permissions'), blank=True)
</p>

<p>
objects = GroupManager()
</p>

<p>
其他的认证源
</p>

<p>
一般django自带的认证系统已经满足了大部分情况下的需求，但如果你有新的的需求的时候，你可以是用其他的认证源
具体化认证后端
</p>

<p>
django有一个检查用户名密码的“认证后端”的列表，django会从列表的第一项开始尝试，直到找到匹配的一项或者最后一项位置，你可以是用AUTHENTICATION_BACKENS设置你的认证后端列表
自己写一个认证后端
</p>

<p>
一个认证后端是指一个实现了两个必选方法和一系列可选权限相关的方法的类：get_user(user_id)和authenticate(**credentials)（ get_group_permissions() ,  get_all_permissions() , has_perm() , and  has_module_perms() )）
</p>

<p>
其中get_user(user_id)中的user_id可以是用户名，数据库ID或者其他 ，返回一个用户对象
</p>

<p>
authenticate把credentials的内容作为关键字参数 ，可能是这样
</p>

<p>
class MyBackend(object):
    def authenticate(self, username=None, password=None):
</p>

<p>
或者是这样
</p>

<p>
class MyBackend(object):
    def authenticate(self, token=None):
</p>

<p>
无论如何，authenticate都应该验证credentials中的内容，然后返回一个符合哪些验证条件的用户对象，或者None
</p>

<p>
这是一个后端的例子
</p>

<p>
from django.conf import settings
from django.contrib.auth.models import User, check_password
class SettingsBackend(object):
  """
  Authenticate against the settings ADMIN_LOGIN and ADMIN_PASSWORD.
  Use the login name, and a hash of the password. For example:
  ADMIN_LOGIN = 'admin'
  ADMIN_PASSWORD = 'sha1$4e987$afbcf42e21bd417fb71db8c66b321e9fc33051de'
  """
  supports_inactive_user = False
  def authenticate(self, username=None, password=None):
    login_valid = (settings.ADMIN_LOGIN == username)
    pwd_valid = check_password(password, settings.ADMIN_PASSWORD)
    if login_valid and pwd_valid:
      try:
        user = User.objects.get(username=username)
      except User.DoesNotExist:
</p>

<p>
      user = User(username=username, password='get from settings.py')
      user.is_staff = True
      user.is_superuser = True
      user.save()
    return user
  return None
def get_user(self, user_id):
  try:
    return User.objects.get(pk=user_id)
  except User.DoesNotExist:
    return None
</p>
</div>
</div>

<div id="outline-container-orgb99acb1" class="outline-2">
<h2 id="orgb99acb1"><span class="section-number-2">3</span> 发布</h2>
</div>
<div id="outline-container-org9c38ad0" class="outline-2">
<h2 id="org9c38ad0"><span class="section-number-2">4</span> 安装Apache,libapache2-mod-wsgi</h2>
</div>
<div id="outline-container-orgbfe68ab" class="outline-2">
<h2 id="orgbfe68ab"><span class="section-number-2">5</span> 配置</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org4f771fd" class="outline-3">
<h3 id="org4f771fd"><span class="section-number-3">5.1</span> 一是站点配置，</h3>
</div>
<div id="outline-container-orgd1c045c" class="outline-3">
<h3 id="orgd1c045c"><span class="section-number-3">5.2</span> 二是wsgi配置</h3>
<div class="outline-text-3" id="text-5-2">
<p>
WSGIScriptAlias / "/search/lizhigang/mysite/mysite/wsgi.py"
WSGIPythonPath /search/lizhigang/mysite
</p>

<p>
&lt;Directory "/search/lizhigang/mysite/mysite"&gt;
&lt;Files wsgi.py&gt;
Order deny,allow
Allow from all
&lt;/Files&gt;
&lt;/Directory&gt;
</p>
</div>
</div>
<div id="outline-container-org96a3ad4" class="outline-3">
<h3 id="org96a3ad4"><span class="section-number-3">5.3</span> Mysql 配置</h3>
<div class="outline-text-3" id="text-5-3">
<p>
apt-get  install python-mysqldb
pip install MySQL-python
sudo apt-get install libmysqlclient-dev
sudo apt-get install python-dev
</p>
</div>
</div>
</div>
<div id="outline-container-org8a637f2" class="outline-2">
<h2 id="org8a637f2"><span class="section-number-2">6</span> 上传</h2>
<div class="outline-text-2" id="text-6">
<p>
gzip -c lfile | ssh root@123.57.158.95 "gunzip -c - &gt; /alidata/www/rfile"
</p>
</div>
</div>

<div id="outline-container-org1fbf7a8" class="outline-2">
<h2 id="org1fbf7a8"><span class="section-number-2">7</span> 物业管理内容</h2>
<div class="outline-text-2" id="text-7">
<p>
　　物业管理服务应当保持住宅和公共设施完好、环境整洁优美、公共秩序良好，保障物业使用方便、安全，并按照下列要求实施：
</p>

<p>
　　(一)按照国家和本市规定的技术标准和规范以及业主委员会审定的物业管理服务年度计划，实施管理服务;
</p>

<p>
　　(二)在业主、使用人使用房屋前，将住宅的共用部位、共用设备和公共设施使用、维护的方法、要求、注意事项以及法规、规章的有关规定书面告知业主、使用人;
</p>

<p>
　　(三)经常对物业管理区域进行全面的巡视、检查，定期对住宅的共用部位、共用设备和公共设施进行养护;
</p>

<p>
　　(四)发现住宅的共用部位、共用设备或者公共设施损坏时，立即采取保护措施，并按照物业管理服务合同的约定进行维修;
</p>

<p>
　　(五)接到物业损坏报修时，限时进行维修和处理;
</p>

<p>
　　(六)做好物业维修、更新及其费用收支的各项记录，妥善保管物业档案资料和有关的财务帐册;
</p>

<p>
　　(七)每半年向业主委员会报送物业维修、更新费用的收支帐目，接受审核;
</p>

<p>
　　(八)定期听取业主委员会、业主、使用人的意见和建议，改进和完善管理服务;
</p>

<p>
　　(九)发现违反本条例或者业主公约的行为，立即进行劝阻、制止，并向业主委员会和有关行政机关报告;
</p>

<p>
　　(十)按照物业管理服务合同约定的要求，做好业主委员会、业主、使用人委托的其他管理服务事项。
</p>

<p>
　　除前款规定外，物业管理企业应当配合居民委员会做好社区管理、社区服务的有关工作。
</p>

<p>
　　物业管理通常包括两大内容：日常管理和特约服务。
</p>

<p>
　　日常管理
</p>

<p>
　　日常管理是经济性的管理和服务，包括以下内容：
</p>

<p>
　　日常养护
</p>

<p>
　　对于一个物业来说，配套的机电设备、供水、供电系统、共用设施等应经常、定期地进行养护，让其维持良好的运行状态，延长设备的使用寿命。
</p>

<p>
　　清洁绿化
</p>

<p>
　　对一个住宅小区来说，搞好清洁绿化工作可为业主和住户创造良好、舒适的工作、生活环境，培养人们亲近自然的意识，热爱自然、热爱生活。
</p>

<p>
　　安全保卫
</p>

<p>
　　在现实生活中，每个人都希望有安全感。物业管理应切实做好安全保卫工作，将不安全因素消灭在萌芽状态，让业主和使用人无后顾之忧，确保人们的生命财产安全。
</p>

<p>
　　消防工作
</p>

<p>
　　物业管理应高度重视消防工作，一定要保证消防设备处于良好待用状态，并培训一支业余消防队伍，一遇火情可立即作出反应。另外，还要提高业主和使用人的防火和自救意识。
</p>

<p>
　　日常维护
</p>

<p>
　　物业在使用过程中会出现很多问题，须有一支全天侯的维修队伍，随叫随到，及时处理各类小修、急修工作，方便业主和使用人。
</p>

<p>
　　征收各类费用、保管使用管理基金
</p>

<p>
　　定期收取管理费，编制预算、收支帐目，并定期公布，以便业主和使用人监督。
</p>

<p>
　　协调各方面社会关系
</p>

<p>
　　物业管理公司应与派出所、街道居委会经常保持联系，协调好工作。管理公司还应与物业相关的政府各部门如供水、供电、煤气、电信、市政等进行沟通，以便出现情况都可与有关部门配合，尽快予以解决。
</p>

<p>
　　处理好物业内部人际关系
</p>

<p>
　　一个大型物业内部居住着各种职业、性格的业主和用户，物业管理公司可通过开展联谊活动，让业主和用户有机会交流，加深理解，减少纠纷和争执的发生。
</p>

<p>
　　特约服务
</p>

<p>
　　特约服务是指根据业主和住户需要，提供各类特别服务，这些通常是有偿的。如送奶送报，看护老人、病人、儿童，订票送票，代为购物，送货上门等等。
</p>

<p>
　　物业管理公司还可利用部分物业开展多种经营，增加收入，补充管理经费不足，减轻业主和住户的负担。
</p>
</div>
</div>
</div>
</body>
</html>