<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2021-10-02 Sat 10:56 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Elisp Keymaps 翻译</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu Peng" />
<link rel='stylesheet' type='text/css' href='file:///home/paul/mynotes/publish/css/org.css' /><link rel='stylesheet' type='text/css' href='file:///home/paul/mynotes/publish/css/header.css' />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div class="site_header"><div class="site_title" ><div class="title_main">WuPeng's Notes - 我的知识库</div><div class="title_sub">不积跬步，无以至千里；不积小流，无以成江海</div><div class="search"></div></div><div class="nav_bar"><ul><li><a href="file:///home/paul/mynotes/publish/index.html">笔记</a></li><li><a href="file:///home/paul/mynotes/publish/inbox.html">收集</a></li><li><a href="#contact">Contact</a></li><li style="float:right"><a href="file:///home/paul/mynotes/publish/about.html">关于</a></li></ul></div></div>
</div>
<div id="content">
<h1 class="title">Elisp Keymaps 翻译</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdc00410">1. 搜索按键映射</a></li>
<li><a href="#org801ca6b">2. 控制活动映射表</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdc00410" class="outline-2">
<h2 id="orgdc00410"><span class="section-number-2">1</span> 搜索按键映射</h2>
<div class="outline-text-2" id="text-1">
<p>
这是 Emacs 如何搜索按键映射的伪代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">or</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> overriding-terminal-local-map
        <span class="org-rainbow-delimiters-depth-3">(</span>FIND-IN overriding-terminal-local-map<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> overriding-local-map
        <span class="org-rainbow-delimiters-depth-3">(</span>FIND-IN overriding-local-map<span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">or</span> <span class="org-rainbow-delimiters-depth-4">(</span>FIND-IN <span class="org-rainbow-delimiters-depth-5">(</span>get-char-property <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span> 'keymap<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
          <span class="org-rainbow-delimiters-depth-4">(</span>FIND-IN-ANY emulation-mode-map-alists<span class="org-rainbow-delimiters-depth-4">)</span>
          <span class="org-rainbow-delimiters-depth-4">(</span>FIND-IN-ANY minor-mode-overriding-map-alist<span class="org-rainbow-delimiters-depth-4">)</span>
          <span class="org-rainbow-delimiters-depth-4">(</span>FIND-IN-ANY minor-mode-map-alist<span class="org-rainbow-delimiters-depth-4">)</span>
          <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span>get-text-property <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span> 'local-map<span class="org-rainbow-delimiters-depth-5">)</span>
              <span class="org-rainbow-delimiters-depth-5">(</span>FIND-IN <span class="org-rainbow-delimiters-depth-6">(</span>get-char-property <span class="org-rainbow-delimiters-depth-7">(</span>point<span class="org-rainbow-delimiters-depth-7">)</span> 'local-map<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">(</span>FIND-IN <span class="org-rainbow-delimiters-depth-6">(</span>current-local-map<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">(</span>FIND-IN <span class="org-rainbow-delimiters-depth-3">(</span>current-global-map<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

</pre>
</div>

<p>
这里 FIND-IN 和 FIND-IN-ANY 是用于搜索一个映射表我多个映射表的伪代码函数。注意的
是 `set-transient-map' 函数通过设置 `overriding-terminal-local-map' 变量起作用
（请看 Controlling Active Maps）。
</p>

<p>
在上面的伪代码中，如果按键序列以鼠标事件开始（请看 Mouse Events），则会使用事件
的位置而不是字符光标位置，同时使用鼠标事件缓冲而不是当前缓冲。这会影响 `keymap'
和 `local-map' 属性的查找。如果鼠标事件发生在一个嵌有 `display'，
`before-string'，或者 `after-string' 属性的字符串上（请看 Special Properties），
并且字符串的 `keymap' 或者 `local-map' 的值不是 `nil'，那么则会覆盖鼠标下面的缓
冲文本的相应的属性。
</p>

<p>
当从按键映射表中找到一个按键绑定时，如果绑定的是一个命令，命令上的搜索会被执行。
但是，如果绑定的是一个带有值或者字符串的符号，Emacs 会使用这个值或者字符串去替换
按键序列，再使用新的序列去搜索按键绑定。请看 Key Lookup。
</p>

<p>
最后被搜索到的命令还可能被重映射。请看 Remapping Commands。
</p>
</div>
</div>

<div id="outline-container-org801ca6b" class="outline-2">
<h2 id="org801ca6b"><span class="section-number-2">2</span> 控制活动映射表</h2>
<div class="outline-text-2" id="text-2">
<p>
&#x2013; 变量： global-map
</p>

<p>
这个变量保存了 Emacs 按键到命令的默认全局映射表。全局映射通过是这个映射。默认的
全局映射是一个全表，将所有的可打印的字符绑定到了 `self-insert-command' 上面。
</p>

<p>
重新绑定全局按键映射是平常的操作，但是你不应该将这个变量的值设置成其他的按键映射表。
</p>

<p>
&#x2013; 函数： current-global-map
</p>

<p>
这个函数返回当前的全局映射表。这个结果应该和 `global-map' 的值是一样的，除非你修
改了其他的一个。返回的值是一个指针而不是副本，如果你在返回值上使用 `define-key'
或者其他函数，你将会修改全局绑定。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>current-global-map<span class="org-rainbow-delimiters-depth-1">)</span>
&#8658; <span class="org-rainbow-delimiters-depth-1">(</span>keymap <span class="org-rainbow-delimiters-depth-2">[</span>set-mark-command beginning-of-line ...
            delete-backward-char<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

</pre>
</div>

<p>
&#x2013; 函数： current-local-map
</p>

<p>
这个函数返回当前缓冲区的局部映射表，或者在没有局部映射表时返回 `nil'。在下面的例子
中，`*scratch*' 缓冲区中的按键映射表是一个稀疏表，而表中的针对 &lt;ESC&gt;，ASCII 码是
27 的条目对映的又是另一个稀疏表。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>current-local-map<span class="org-rainbow-delimiters-depth-1">)</span>
&#8658; <span class="org-rainbow-delimiters-depth-1">(</span>keymap
    <span class="org-rainbow-delimiters-depth-2">(</span>10 . eval-print-last-sexp<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">(</span>9 . lisp-indent-line<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">(</span>127 . backward-delete-char-untabify<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">(</span>27 keymap
        <span class="org-rainbow-delimiters-depth-3">(</span>24 . eval-defun<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">(</span>17 . indent-sexp<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

</pre>
</div>

<p>
`current-local-map' 返回一个局部表的引用，而不是一个副本，如果你在返回值上使用
`define-key' 或者其他函数的话，则会修改局部绑定。
</p>

<p>
&#x2013; 函数： current-minor-mode-maps
</p>

<p>
这个函数返回一个开启状态的子模式的按键映射表的列表。
</p>

<p>
&#x2013; 函数： use-global-map keymap
</p>

<p>
这个函数将 KEYMAP 设置成新的全局按键映射表，并返回 `nil'。
</p>

<p>
实际上很少修改全局的映射表。
</p>

<p>
&#x2013; 函数： use-local-map keymap
</p>

<p>
这个函数将 KEYMAP 设置成当前缓冲区的新的局部映射表。 如果 KEYMAP 是 `nil' ，当前
缓冲区则没有局部映射表。 `use-local-map' 返回 `nil'。 大多数的主模式命令使用这个
函数。
</p>

<p>
&#x2013; 变量： minor-mode-map-alist
</p>

<p>
这个变量是一个列表，关于由变量决定的已经打开或者没有打开的子模式的映射表的集合。列表的元素像
这样： 
</p>

<p>
(VARIABLES . KEYMAP)
</p>

<p>
当 VARIABLES 的值不是 `nil' 时，映射表 KEYMAP 则处于激活状态。 通常情况下，
VARIABLES 是开启或者关闭子模式的变量。请看 Keymaps and Minor Modes。
</p>

<p>
要注意的是， `minor-mode-map-alist' 的元素与 `minor-mode-alist' 的元素是不一样的。
映射表应该是元素的 CDR 的结果，映射表是第二个元素的列表是错误的。CDR 可以是一个
映射表（列表）或者一个函数定义为映射表的符号。
</p>

<p>
当不止一个子模式的映射表处于活动状态时，处于 `minor-mode-map-alist' 头部的映射表
有更高的优先级。但是你在定义子模式的时候应该做到互不干扰。当你恰当处理这些的时候，
映射表的顺序就没有关系了。
</p>

<p>
请看 Keymaps and Minor Modes，来了解子模式的更多信息，同时请了解
`minor-mode-key-binding' (请看 Functions Key Lookup)。
</p>

<p>
&#x2013; 变量： minor-mode-overriding-map-alist
</p>

<p>
这个变量允许主模式重载某些子模式的按键绑定。这个列表的元素和
`minor-mode-map-alist' 中的元素看起来一样： `(VARIABLES . KEYMAP)'。
</p>

<p>
如果 `minor-mode-overriding-map-alist' 中的元素是一个变量的话，通过这个元素设置
的映射表会替换掉在 `minor-mode-map-alist' 中使用相同变量设置的映射表。
</p>

<p>
`minor-mode-overriding-map-alist' 针对每个缓冲区是一个缓冲局部变量。
</p>

<p>
&#x2013; 变量： overriding-local-map
</p>

<p>
如果其值不是 `nil'，他绑定的是一个替换缓冲区局部映射表、文本属性或者重叠遇映射表
和所有子模式映射表的映射表，当这个映射表被设置后，会覆盖所有其他的按键映射，除了
当前的全局映射。
</p>

<p>
&#x2013; 变量： overriding-terminal-local-map
</p>

<p>
如果其值不是 `nil'，那么它绑定的是一个用于替换 `overriding-local-map' 和缓冲区局
部映射、文本属性或者重叠映射和其他所有子模式映射的按键映射
表。这个变量对当前终端始终是局部影响的，但不能是缓冲局部的。请看 Multiple
Terminals。这用于实际增量搜索模式。
</p>

<p>
&#x2013; 变量： overriding-local-map-menu-flag
</p>

<p>
如果这个变量的值不是 `nil'，那么 `overriding-local-map' 和
`overriding-terminal-local-map' 的值可以影响菜单条的显示。默认值是 `nil'，所以这
些映射表变量对菜单条是没有作用的。
</p>

<p>
注意的是，这两个映射表变量在使用菜单条输入按键序列的运行会有影响，即使他们不会影
响菜单条的显示。所以，如果收到菜单条按键序列，你应该先清除这些变量，再去搜索和执
行按键序列。使用这些变量的模式通常都会这样干，通过使用 "unreading" 来响应这些不
用处理的事件并退出。
</p>

<p>
&#x2013; 变量： special-event-map
</p>

<p>
这个变量保存了针对特殊事件的键盘映射表。如果事件在表中有一个绑定，那么他则是特殊
事件，针对这个事件的绑定也会通过 `read-event' 直接运行。请看 Special Events。
</p>

<p>
&#x2013; 变量： emulation-mode-map-alists
</p>

<p>
这个变量保存了在仿真模式中使用的按键映射表列表。主要针对那些使用多个子模式按键映
射表的模式或者包。每个元素是一个与 `minor-mode-map-alist' 的元素格式和意义相同的
映射表列表，或者是一个绑定有这种列表的变量的符号。 每个列表中的活动映射表在
`minor-mode-map-alist' 和 `minor-mode-overriding-map-alist' 之前使用。
</p>

<p>
&#x2013; 函数： set-transient-map keymap &amp;optional keep-pred on-exit
</p>

<p>
这个函数将 KEYMAP 作为一个过渡的映射表，其后的一个（或者更多）按键会使用这个映射
表而不是其他映射表。
</p>

<p>
通常情况下，KEYMAP 只使用一次，针对紧接其后的按键。
</p>

<p>
如果可选参数 KEEP-PRED 是 `t'，那么映射表会根据 KEYMAP 中定义的按键生存尽可能长
的时间，当用户按了一个在 KEYMAP 中不存在的按键时，过渡映射表将转换为不活动的状态，
常规的按键搜索将进行下去。
</p>

<p>
KEEP-PRED 参数还可以是一个函数。这种情况下，当 KEYMAP 处于激活状态时，函数将在后
来每个命令之前不使用参数进行调用，如果 KEYMAP 应该保持激活状态的话，函数应该返回
一个 non-`nil' 值。
</p>

<p>
可选参数 ON-EXIT 的值如果不是 `nil'，则应该指定一个用于调用的函数，函数不使用参
数，当 KEYMAP 被关闭时被调用。
</p>

<p>
这个函数通过从变量 `overriding-terminal-local-map' 中添加和称除 KEYMAP 来实现，
KEYMAP 会在其他所有活动映射表前被搜索（请看 Searching Keymaps）。
</p>


<p>
本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a> 进行许可。
</p>
</div>
</div>
</div>
</body>
</html>